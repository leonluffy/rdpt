#ifndef _SECPAIR_H_
#define _SECPAIR_H_

#include "rdpt_prot.h"
#include "string.h"

#define SP_DATALEN_ALIGN(l, len)			((((l) + (len) - 1) / (len)) * (len))

#define CRYPTO_KEYLEN			16
#define CRYPTO_PLAINTEXT_LEN	16

typedef struct _aes128_ptpercp {
	unsigned char		pt[CRYPTO_PLAINTEXT_LEN];
} aes128_ptpercp_t;

/* we use the AES128
 * keylen --> 128bit
 * in(128bit) ----> out(128bit)
 */
class aes_cipher {
public:
	aes_cipher()
	{
		memset(m_k, 0, sizeof(m_k));
		memset(m_w, 0, sizeof(m_w));
	}
	aes_cipher(const void *key)
	{
		setkey(key);
	}
	void setkey(const void *key);
	void docipher(aes128_ptpercp_t *in, aes128_ptpercp_t *out, unsigned n_cip);
	void decipher(aes128_ptpercp_t *in, aes128_ptpercp_t *out, unsigned n_cip);
	void *getkey()
	{
		return m_k;
	}
	//u16					keylen;
	//u16					msglen;
private:
	unsigned char			m_k[CRYPTO_KEYLEN];
	/* generated by key, call key_expansion() */
	unsigned char			m_w[4 * (10 + 1) * 4];
};

typedef enum _secpair_fh_type {
	SECPAIR_FH_TYPE_AUTH = RDPT_SOCKDATA_EXT,
	SECPAIR_FH_TYPE_AUTH_REPLY,
	SECPAIR_FH_TYPE_TAPOPEN,
	SECPAIR_FH_TYPE_TAPOPEN_REPLY,
	SECPAIR_FH_TYPE_COUNT
} secpair_fh_type_e;

#define SECPAIR_FLAG_AUTH			0x1

typedef rdpt_sockdata_t secpair_fh_t;

/* sub head: auth */
typedef struct _secpair_fsh_auth {
	unsigned			chng_c;
	unsigned			chng_s;
	unsigned			rootkey_d0;
	unsigned			rootkey_d1;
} secpair_fsh_auth_t;

typedef struct _secpair_fsh_authreply {
	unsigned			chng_c;
	unsigned			chng_s;
	unsigned			rootkey_d2;
	unsigned			rootkey_d3;
} secpair_fsh_authreply_t;

typedef struct _secpair_keygen {
	unsigned			rootkey_d3;
	unsigned			chng_s;
	unsigned			rootkey_d1;
	unsigned			chng_c;
} secpair_keygen_t;

typedef enum _secpair_state {
	SECPAIR_STATE_CLOSED,
	SECPAIR_STATE_AUTHING,
	SECPAIR_STATE_AUTHING_REPLY,
	SECPAIR_STATE_ESTABLISHED,
	SECPAIR_STATE_COUNT
} secpair_state_e;

typedef int (*sp_fproc)(secpair_fh_t *spfh, void *param);
typedef unsigned (*randfunc)();

class secpair {
public:
	secpair(sp_fproc recv, sp_fproc sp_send, randfunc rand, const char *key, void *param);
	int send(void *buf, unsigned len, unsigned type);
	int sp_recv(secpair_fh_t *spfh);
	int startup();
protected:
	aes_cipher		m_session;
	aes_cipher		m_root;

	sp_fproc		m_recv;
	sp_fproc		m_sp_send;
	randfunc		m_randfunc;
private:
	void reset()
	{
		m_chng_c = 0;
		m_state = SECPAIR_STATE_CLOSED;
	}
	void gensession()
	{
		unsigned *rootkey = (unsigned *)m_root.getkey();

		/* calc session */
		secpair_keygen_t keygen;
		keygen.chng_c = m_chng_c;
		keygen.chng_s = m_chng_s;
		keygen.rootkey_d1 = rootkey[1];
		keygen.rootkey_d3 = rootkey[3];
		m_root.decipher((aes128_ptpercp_t *)&keygen, (aes128_ptpercp_t *)&keygen, 1);
		m_session.setkey(&keygen);

		m_state = SECPAIR_STATE_ESTABLISHED;
	}
	volatile secpair_state_e	m_state;
	unsigned		m_chng_c, m_chng_s;
	void			*m_param;
};

#endif

